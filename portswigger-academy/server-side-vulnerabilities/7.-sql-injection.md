---
icon: database
---

# 7. SQL injection

<div align="center">

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwrYxJeahR9_oCFquK0xWL2NrSjo-JsQmflg&#x26;s" alt="" height="200" width="200">

</div>

## SQL Injection (SQLi)

_SQL Injection_. Es una vulnerabilidad que manipula consultas a bases de datos SQL legitimas para obtener información sensible almacenado en las bases de datos. La información puede variar, desde información de los clientes, información del mismo sistema, credenciales privilegiadas o credenciales de otros usuarios. En algunos casos, el atacante incluso tiene la posibilidad de modificar o eliminar los datos dentro de la base de datos causando cambios persistentes en el contenido o comportamiento.

## Detección

Es posible detectar este tipo de vulnerabilidades de forma manual usando una serie de pruebas semánticas en cada punto de entrada de la aplicación además de la existencia de múltiples herramientas que automatizan la labor, entre las que destaca [sqlmap](https://github.com/sqlmapproject/sqlmap) por su popularidad, eficiencia y simplicidad.

## Ejemplos

Un escenario puede darse en el sitio web de una tienda que muestra los productos en diferentes categorías. Cuando el usuario da _click_ en la categoría _Gifts_, el buscador realiza una petición al URL: `https://insecure-website.com/products?category=Gifts` Lo que causa que la aplicación realice una consulta SQL para retornar los detalles relevantes de los productos almacenados en la base de datos, la consulta completa, usando el valor `Gifts` obtenido desde el parámetro `category` podría verse así: `SELECT * FROM products WHERE category = 'Gifts' AND released = 1` Lo que se traduce en una petición que retorne:

* Todos los detalles (`SELECT *`)
* De la tabla productos (`FROM products`)
* Donde la categoría sea `Gifts` (`WHERE category = 'Gifts'`)
* Y el valor de `released` sea igual a `1`, lo que puede significar que el siguiente parámetro sea que el producto ya esté a la venta y que nos ayuda a inferir la existencia de productos con valor `release` diferente a `1` que no se encuentren a la venta actualmente (`AND released = 1`) En este escenario, la aplicación no implementa defensa alguna contra _SQL injection_. Lo que significa que el atacante puede manipular la consulta para envenenarla para alterar su comportamiento como en el siguiente ejemplo: `https://insecure-website.com/products?category=Gifts'--` Lo que resultaría en la siguiente consulta: `SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1` Truncando la consulta hasta acabar el filtro por categoría igual a `Gifts` al inyectar los caracteres `--` que son reservados para los comentarios dentro de SQL al igual que el conjunto de caracteres `/*`

> **comentarios simples** Los comentarios simples comienzan con dos guiones consecutivos (--) y finalizan con el final de línea. **comentarios compuestos** Los comentarios compuestos empiezan por /\* y finalizan por \*/ - [IBM Docs](https://www.ibm.com/docs/es/db2woc?topic=statements-sql-comments)

Lo que significa que todo después de los caracteres `--` será invalidado, en este caso, no se aplicará el filtro `released = 1` anidado haciendo que la consulta: `SELECT * FROM products WHERE category = 'Gifts'--' AND released = 1` Sea equivalente a solo: `SELECT * FROM products WHERE category = 'Gifts'` Derivando en retornar todos los productos de la categoría `Gifts` incluyendo los no puestos a la venta aún. Puedes usar un ataque similar para causar que la aplicación muestre todos los productos en cualquier categoría, incluyendo esos productos de los que no conoces su categoría: `https://insecure-website.com/products?category=Gifts'+OR+1=1--` Esto resulta en la siguiente consulta SQL: `SELECT * FROM products WHERE category = 'Gifts' OR 1=1--' AND released = 1` La consulta modificada retorna:

* Todos los productos (`SELECT * FROM products`)
* Donde la categoría sea igual a `Gifts` (`WHERE category = 'Gifts'`)
* O todo lo demás (`OR 1=1--`) Este último puede ser el más confuso de todos, pero revisando de cerca puedes ver que el fragmento de consulta indica una condición, que se puede leer así _Que se cumpla X condición o 1=1--_ donde X es el filtro por categoría `Gifts` entonces también sería equivalente a _Que la categoría sea igual a Gifts o 1=1--_ La parte de `1=1` es una operación condicional simple, que resulta en verdad, se puede leer de la siguiente forma _¿Uno es igual a cero?_ y el resultado que sería _true_ o _verdad_ sería el cual funcionara como parámetro a evaluar, lo que significa que **también** la consulta equivale a _Que la categoría sea igual a Gifts o verdad--_ Ahora es cuestión de aislar los filtros para entender su resultado, los filtros serían _categoría igual a Gifts_ y _Categoría igual a verdad_, el primero es intuitivo, pero el segundo no tanto, pero lo único que se tiene que entender es que evalúa la existencia de _Categoría_, indistintamente de su valor, lo que significa que no importa cual sea su _Categoría_ siempre y cuando exista, entonces los filtros **también** se pueden leer como _Que la Categoría sea igual a Gifts o que contenga una Categoría_, terminando en una lectura simple y amigable después de todo el proceso ==_Selecciona todos los productos que su categoría sea igual a Gifts o que tengan categoría_== En un inicio puede parecer un proceso complejo, por lo que recomiendo asentar bases de lógica matemática sí se busca profundizar en las consultas de bases de datos, además de estudiar conjuntos y todo tema teórico que ayude a su comprensión.

> Cuando se realice una consulta a una base de datos que involucre `1=1` y métodos de alteración o destrucción como lo son _UPDATE_ y _DELETE_, ya que puedes alterar todos los datos dentro de la tabla o todos los datos globales.

Este mismo concepto se puede extrapolar en consultas más sensibles, como consultas a bases de datos durante un formulario de inicio de sesión, un ejemplo puede ser un formulario con los campos _Username_ y _Password_ los cuales manda los valores al _back-end_ para hacer una consulta a la base de datos que podría ser la siguiente: `SELECT * FROM users WHERE username = '' AND password = ''` Así quedaría en un ejemplo práctico donde usemos un supuesto _username_ con valor _winie_ y un _password_ de valor _peter_ que son credenciales legitimas, la consulta final se vería de la siguiente forma: `SELECT * FROM users WHERE username = 'winie' AND password = 'peter'` La consulta retornará un resultado existente, lo que corrobora el correcto empate entre usuario y contraseña registrado en una base de datos. Pero usando la misma metodología basada en una operación lógica que devuelva _verdad_ como resultado, seguido de caracteres para comentar y anular el resto de la consulta, podemos crear una consulta maliciosa que nos ayuda a evadir la necesidad de empate entre usuario y contraseña, podemos usar un username existente conocido, en este caso el mismo _winie_ pero dentro del campo _password_ en vez de poner la contraseña legítima, se manda el _payload_ que truncará la consulta y evitará empatar usuario y contraseña _' OR 1=1--_ Lo que nos dejará con una consulta final: `SELECT * FROM users WHERE username = 'winie' AND password = '' OR 1=1--` Que se puede leer como _Selecciona todos los usuarios donde username sea igual a winie y password vacía o verdad_ que a su vez se puede leer como _Selecciona todos los usuarios donde username sea igual a winie y password vacía o que contenga contraseña_ y así haciendo una consulta que en caso de existencia de un usuario de nombre _winie_ y que tenga contraseña, entonces devuelva el usuario, permitiendo el acceso a la cuenta de usuario. En el supuesto anterior, se conocía previamente el nombre de usuario _winie_ y su contraseña, pero un atacante puede probar con cualquier nombre de usuario, incluso probando con los nombres de usuario con privilegios más habituales como _admin_, y que al tampoco requerir la contraseña real del usuario, puede acceder de forma ilegítima sustituyendo el nombre de usuario _winie_ por el deseado, dejando una consulta: `SELECT * FROM users WHERE username = 'admin' AND password = '' OR 1=1--` Que le brindará privilegios administrativos.

## References

[https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/sql-injection-apprentice/sql-injection/what-is-sql-injection-sqli ](https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/sql-injection-apprentice/sql-injection/what-is-sql-injection-sqli)

[https://github.com/sqlmapproject/sqlmap](https://github.com/sqlmapproject/sqlmap)
