---
icon: fingerprint
---

# 3. Authentication vulnerabilities

<div align="center">

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwrYxJeahR9_oCFquK0xWL2NrSjo-JsQmflg&#x26;s" alt="" height="200" width="200">

</div>

## Authentication vulnerabilities

Recordando un poco sobre el concepto de autenticación. La autenticación es el método por el cual se corrobora que un usuario es quien dice ser, este concepto es fácilmente confundido con el concepto de autorización, cabe mencionar que están relacionados pero no son lo mismo. La autenticación se basa en corroborar la identidad del usuario por medio de **Lo que es, lo que sabe y lo que tiene**. Por ejemplo, un ejemplo de una forma de autenticación basada en **lo que un usuario es**, podrían ser una autenticación que corrobore los datos biométricos del usuario, de esta forma se garantiza la identidad del usuario por lo que es, un ejemplo basado en **lo que sabe** puede ser la autenticación basada en contraseñas, donde en teoría el usuario es el único que conoce su propia contraseña y gracias a esa información que **sabe** puede identificarse. Para un ejemplo de autenticación basada en **lo que se tie** se puede sugerir la autenticación por llave de acceso física USB, la cual puede contener un certificado digital que valide la identidad del usuario. Posterior a una breve reflexión sobre el concepto de autenticación, es en concepto, fácil de entender a lo que nos referimos con vulnerabilidades de autenticación, donde la mayoría se basan en prácticas pobres ó nulas. Vulnerabilidades que permiten a un atacante acceder a datos sensibles ajenos, que pueden ser datos sensibles del negocio o de otros usuarios.

### Ataques

* **Ataques de fuerza bruta** Los ataques de fuerza bruta, del inglés _Brute-force attacks_, se refiera a una técnica para burlar los métodos de autenticación, basado en probar todas las posibilidades de valores de entrada hasta obtener uno válido. Este ataque es fácil de entender, fácil de realizar pero depende completamente del tiempo que tenga el atacante y de que no exista una restricción de intentos del lado del servidor. Este tipo de ataque sirve para obtener una enorme cantidad de datos sensibles, tantos como permita el sistema, puede ser optimizado con el uso de _wordlist_ que son una colección o múltiples, de palabras perfiladas para un objetivo en concreto. Algunos casos de los que puedes encontrar _wordlist_ muy bien perfiladas pueden ser _wordlist_ para contraseñas comunes, usuarios comunes, _payloads_, etc. Incluso el atacante puede generar sus propias _wordlist_ perfiladas a un objetivo concreto, basado en datos previamente recolectados, como usuarios enumerados ó en elementos dentro del mismo sitio. La complejidad del dato al que se quiera llegar en un supuesto donde se parta sin conocimiento absoluto del objetivo define el tiempo que se tardaría el atacante en obtenerlo, fácilmente un dato puede ser equivalente a un tiempo inviable de espera para el atacante, aún así, para el usuario común quien acostumbra a la mala _praxis_ de su privacidad se verá en una situación incómoda al observar su contraseña dentro de una de estas _wordlist_. Así que como medida contra este tipo de ataques se sugiere un límite de intentos.
* **Enumeración inferida** La enumeración inferida se basa en observar meticulosamente el comportamiento del sitio web en búsqueda de un comportamiento que delate como procesa la información. En un ejemplo básico y reiterado, un portal de _login_ donde, en un escenario común, el usuario ingresa sus credenciales para acceder y, si se equivoca en el nombre de usuario, el sitio responde con un error que revela más información de la que debería como lo podría ser `El usuario ingresado no existe`, el atacante puede tomar dicha información para probar múltiples valores hasta que el comportamiento cambie. Por lo anterior, se sugiere usar mensajes de error genéricos en la medida de lo posible, tal vez como `Credenciales incorrectas` ó mejor aún `Error al iniciar sesión`. Aún así, el atacante puede no requerir de información explicita, el atacante puede observar más rigurosamente en comportamientos sutiles, como tiempos de respuesta.
* **Bypassing factor de doble autenticación**
  * El factor de doble autenticación es un implemento de seguridad que busca corroborar la identidad del usuario, siguiendo el concepto que se basa en corroborar la identidad de un usuario según **Lo que es, lo que sabe y lo que tiene**, en este caso en vez de emplear solo uno de estos datos para corroborar la identidad, emplea dos datos para tener mayor certeza de la identidad, frecuentemente se puede ver este método empleado en páginas de autenticación donde a parte de una contraseña (**Lo que sabe**), piden también algún código que será mandado a un número celular asociado previamente (**Lo que tiene**). Este método es robusto en concepto, pero durante la implementación pueden existir múltiples errores o vulnerabilidades generadas por el factor humano al momento de desarrollarlas, como lo pueden ser errores lógicos, donde, una vez ingresada la contraseña, se pida el código de la doble autenticación, pero una vez ingresada ya otorgar al usuario una sesión o estado que indique que la sesión ya está iniciada, haciendo que el pedir el código para corroborar la identidad sea absurdo e inútil, dejando la oportunidad al atacante de tomar los datos de sesión ya generados para proceder con las peticiones.
  * Otro escenario de una débil implementación del doble factor de autenticación podría ser un código predecible, donde la función que genere los códigos de autenticación sea deficiente o simplemente predecible, estas funciones pueden emplear comportamientos genéricos que además usan entradas que se pueden reflejar en el código resultante, como nombres de usuario, abreviaciones u horarios y fechas. Ejemplificando lo anterior, tomemos una función genérica que toma como entrada el nombre de usuario y le agrega la fecha y hora del momento que se realiza la petición para generar el código, un resultado podría ser `atacante260924142530`, el atacante al generar nuevamente dentro de un laboratorio donde pueda recibir el código, al generar un nuevo código el resultado es `atacante260924142540`, partiendo de que la primera petición se realizo usando el usuario _atacante_ y la fecha de la petición fue el _26_ de Septiembre (_09_) del 20_24_ a las _14_ horas con _25_ minutos y _30_ segundos y la segunda petición se realizó usando el usuario _atacante_ y la fecha de la petición fue el _26_ de Septiembre (_09_) del 20_24_ a las _14_ horas con _25_ minutos y _40_ segundos, el atacante puede observar fácilmente el patron que se sigue al momento de generar el código de autenticación, adquiriendo así, la habilidad de predecir el código de autenticación y a su vez la habilidad de autenticarse sin necesidad de poseer el dispositivo del usuario legitimo.

## References

[https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/authentication-apprentice/authentication/authentication-vulnerabilities ](https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/authentication-apprentice/authentication/authentication-vulnerabilities)

[https://r3d.mx/2018/07/31/las-llaves-fisicas-pueden-ser-una-alternativa-para-evitar-el-phishing/](https://r3d.mx/2018/07/31/las-llaves-fisicas-pueden-ser-una-alternativa-para-evitar-el-phishing/)
