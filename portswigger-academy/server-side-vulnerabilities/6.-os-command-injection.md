---
icon: rectangle-terminal
---

# 6. OS command injection

<div align="center">

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwrYxJeahR9_oCFquK0xWL2NrSjo-JsQmflg&#x26;s" alt="" height="200" width="200">

</div>

## OS command injection

_OS command injection_, o solamente _Command Injection_, es un tipo de vulnerabilidad que permite a un atacante ejecutar de forma arbitraria comandos a nivel de sistema operativo mediante el sitio web o aplicación, proporcionando así la oportunidad de ganar acceso parcial o total del sistema al atacante. Incluso, en casos donde no se permita la ejecución de comandos de forma libre, puede implicar un primer vector para explotar sistemas a nivel local, realizar _pivoting_ o cualquier tipo de movimiento lateral.

### Comandos

Es importante remarcar la diferencia entre Sistemas Operativos, ya que los comandos pueden variar significativamente entre ellos, a continuación se muestra una tabla en relación a los comandos, funciones según el Sistema Operativo:

| Propósito                 | Linux       | Windows     |
| ------------------------- | ----------- | ----------- |
| Retorna el usuario actual | whoami      | whoami      |
| Sistema Operativo         | uname -a    | ver         |
| Configuración de red      | ifconfig    | ipconfig    |
| Conexiones de red         | netstat -an | netstat -an |
| Procesos en ejecución     | ps -ef      | tasklist    |

## Ejemplos

En el siguiente ejemplo, veremos una página web que aloja una tienda que permite a los usuarios verificar el inventario de un producto en una tienda en particular. Esta información es accedida mediante la URL `https://insecure-website.com/stockStatus?productID=381&storeID=29`

Para proporcionar la información del inventario, la aplicación debe consultar varios sistemas de legado. Por razones históricas, la funcionalidad es implementada mediante el llamado de un comando con el ID del producto como argumento de la siguiente forma:

```bash
stockreport.pl 381 29
```

Este comando retorna el estatus de inventario del producto especificado mediante el ID, que finalmente es retornado al usuario. La aplicación no implementa defensa alguna para defenderse de un _Command Injection_, por lo que un atacante puede mandar el siguiente valor de entrada en el campo para realizar una ejecución arbitraria de comandos `& echo aiwefwlguh &` que finalmente termina en una ejecución por parte del sistema que luce así:

```bash
stockreport.pl & echo aiwefwlguh & 29
```

El motivo de los caracteres `&` es para indicarle al sistema operativo Linux que se desea ejecutar una serie de comandos de forma asíncrona

> [<<_A single ampersand **&** can also delimit a list of commands to be run asynchronously._>>](https://bashitout.com/2013/05/18/Ampersands-on-the-command-line.html)

Logrando así ejecutar multiples comandos en una sola línea sin depender del estado de ejecución de ningún comando como podría pasar si se ejecutara la misma línea de comandos remplazando el `&` por `&&`, operador lógico `AND` que hace dependiente la ejecución del segundo comando a la correcta ejecución del primer comando

> [<<_A double ampersand **&&** in Bash means **AND** and can be used to separate a list of commands to be run sequentially. Commands separated by a double ampersand **&&** are to be run synchronously, with each one running only if the last did not fail (a fail is interpreted as returning a non-zero return status). This can be especially handy for when you have a couple of commands to run, but you don’t want the second to be run if the first fails._>>](https://bashitout.com/2013/05/18/Ampersands-on-the-command-line.html)

El comando `echo` remplaza la la salida del comando. Es una forma útil para probar algunos tipos de _Command Injection_. La salida del ejemplo anterior luciría de la siguiente forma:

```Bash
Error - productID was not provided aiwefwlguh 29: command not found
aiwefwlguh
29: command not found
```

Siendo `Error - productID was not provided` la salida de error del script al no proporcionar un ID de producto, `aiwefwlguh` como el resultado de nuestro comando `echo` inyectado y `29: command not found` resultado de que el sistema intentara ejecutar `29` de forma aislada como un comando propiamente, que al no existir dentro del sistema, retorna un error que indica que no fue encontrado dicho comando.

## References

[https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/os-command-injection-apprentice/os-command-injection/what-is-os-command-injection ](https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/os-command-injection-apprentice/os-command-injection/what-is-os-command-injection)

[https://bashitout.com/2013/05/18/Ampersands-on-the-command-line.html](https://bashitout.com/2013/05/18/Ampersands-on-the-command-line.html)
