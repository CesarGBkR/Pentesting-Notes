---
icon: file-import
---

# 5. File upload vulnerabilities

<div align="center">

<img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcSwrYxJeahR9_oCFquK0xWL2NrSjo-JsQmflg&#x26;s" alt="" height="200" width="200">

</div>

## File upload vulnerabilities

Este tipo de vulnerabilidad se centra en la mala configuración o nula existencia de filtros de seguridad en las entradas de subida de archivos, los que permiten al atacante alojar archivos maliciosos que alteren el comportamiento esperado de un sistema e incluso le permitan ganar el acceso total al sistema.

## Causas

La causa principal es la debilidad en las políticas de subida de archivos, empleando escasas o nulas reglas para los archivos, existe una serie básica de filtros para garantizar la legitimidad del archivo que se intenta subir. Aún así, el desarrollador debe contemplar las múltiples formas de evadir dichos filtros para robustecer los filtros de seguridad. El atacante puede emplear largas listas de _payloads_ o cargas útiles que buscan evadir los filtros presentes en un sistema, un recurso recurrente el el repositorio [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master) de [Swissky](https://github.com/swisskyrepo), que cuenta con colecciones amplias de _wordlists_ para cada escenario, donde ya incluye _payloads_ ofuscados para evitar los filtros, incluso algunos _payloads_ cuentan con métodos de evasión anidados para mayor porcentaje de efectividad.

### Filtros

Algunos de los filtros que se pueden implementar y a su vez probar su existencia en caso de un atacante son:

* _Filetype_
* Contenido
* Tamaño
* Nombre
* Extensiones

### Validación defectuosa

Cuando se manda un formulario HTML, el buscador normalmente envía el tipo de dato con el _content type Header_ `application/x-www-form-url-encoded`. Usado para mandar un texto simple como un nombre o una dirección. Sin embargo no es eficiente para mandar una gran cantidad de datos binarios como es en el escenario de la subida de imágenes o archivos PDF. En este caso, el _content type_ `multipart/form-data` es preferible. Considera un formulario el cual contiene campos para subir una imagen, proveyendo una descripción a esta e ingresando tu nombre de usuario. Mandando el formulario resulta en una petición que luce como esto:

```Txt
POST /images HTTP/1.1
Host: normal-website.com 
Content-Length: 12345 
Content-Type: multipart/form-data; boundary=---------------------------012345678901234567890123456 ---------------------------012345678901234567890123456
Content-Disposition: form-data; name="image"; filename="example.jpg" Content-Type: image/jpeg 
[...binary content of example.jpg...] 
---------------------------012345678901234567890123456 
Content-Disposition: form-data; name="description" 
This is an interesting description of my image.
---------------------------012345678901234567890123456 
Content-Disposition: form-data; name="username" 
wiener 
---------------------------012345678901234567890123456--
```

Como puedes ver, el cuerpo del mensaje se divide en partes separadas por cada una de las entradas del formulario. Cada parte contiene un `Content-Disposition` que otorga información básica sobre la entrada relacionada. Cada parte individual puede también contener su propio `Content-Type`, que informa al servidor el tipo de [_MIME_](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics\_of\_HTTP/MIME\_types) de los datos mandados. Una de las maneras en que un sitio web puede intentar validad la subida de archivos es mediante la validación del _content type_ del campo mandado, esperando que coincida con el tipo de _MIME_ esperado. Como puede ser que si espera solamente imágenes, solo acepte tipos como `image/jpeg` e `image/png`. Así se evita confiar de primera mando en los _headers_ de los formularios, pues dichos _headers_ pueden ser fácilmente manipulados con herramientas como _Burpsuite_ que en caso de no tener una segunda validación a nivel _back-end_ puede resultar en una evasión de seguridad.

## Ejemplos

### Explotando subidas de archivos sin filtros

Las entradas que esperan un archivo, sin ningún filtro de por medio, pueden ser vulneradas con un _reverse shell_ el cual garantizaría el acceso remoto no deseado a cualquier atacante. Los tipos de archivos mayormente usados para este propósito son los archivos **PHP**, **Java** o **Python**, y que son configurados también para ejecutar código, lo que hace una tarea trivial para el atacante el crear su propio _web shell_ en el servidor. La habilidad de ejecutar una _web shell_ implica que el atacante tiene acceso al control completo del sistema hasta donde el usuario con el que se ejecuta el archivo se lo permita. Un ejemplo de código **PHP** malicioso que ayuda a filtrar información interna es el siguiente: `<?php echo file_get_contents('/path/to/target/file'); ?>` Una vez mandado el código, retornará el archivo del objetivo en la respuesta. Un ejemplo más versátil de un _web shell_ podría lucir así: `<?php echo system($_GET['command']); ?>` El anterior _script_ permite ejecutar de forma arbitraria comandos mediante el parámetro _command_ como se muestra a continuación: `GET /example/exploit.php?command=id HTTP/1.1` Lo que retornaría en la respuesta la salida del comando, que identifica el id del usuario que ejecuta los _scripts_ de la página. Existe una extensa variedad de _web shells_ para cada escenario, un atacante debe de conocer multiples formas para cada caso y en la actualidad existen herramientas que facilitan el armado de _web shells_, _reverse shells_ como podría ser el caso de la página [revshells](https://www.revshells.com/) que pertenece a [Ryan Montgomery (aka. 0dayCTF)](https://github.com/0dayCTF)

## References

[https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/file-upload-apprentice/file-upload/what-are-file-upload-vulnerabilities ](https://portswigger.net/web-security/learning-paths/server-side-vulnerabilities-apprentice/file-upload-apprentice/file-upload/what-are-file-upload-vulnerabilities)

[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master ](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master)

[https://github.com/swisskyrepo ](https://github.com/swisskyrepo)

[https://www.revshells.com/ ](https://www.revshells.com/)

[https://github.com/0dayCTF ](https://github.com/0dayCTF)

[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics\_of\_HTTP/MIME\_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics\_of\_HTTP/MIME\_types)
